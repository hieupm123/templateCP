Bài toán đặt ra như sau: Bạn được cho một xâu s độ dài n(n≤50,000). Bạn cần tìm độ dài của xâu đối xứng dài nhất gồm các kí tự liên tiếp trong s. (Xâu đối xứng là xâu đọc từ 2 chiều giống nhau).

Một ‘thuật toán chuẩn’ không thể áp dụng vào bài toán này đó là thuật toán KMP. Ngoài KMP ra, có 2 ‘thuật toán chuẩn’ có thể áp dụng được. Thuật toán thứ nhất đó là sử dụng thuật toán Manacher để tính bán kính đối xứng tại tất cả vị trí trong xâu. Thuật toán thứ 2 đó là sử dụng Suffix Array và LCP (Longest Common Prefix) cho xâu được nối bởi s và xâu s viết theo thứ tự ngược lại. 2 thuật toán này đều không dễ, và nằm ngoài phạm vi bài viết, nên tôi chỉ nêu sơ qua mà không đi vào chi tiết.
Bây giờ, chúng ta sẽ xét thuật toán ‘không chuẩn’ là thuật toán Hash. Để đơn giản, chúng ta xét trường hợp độ dài của xâu đối xứng là lẻ (trường hợp chẵn xử lý hoàn toàn tương tự).
Giả sử xâu đối xứng độ dài lẻ dài nhất có độ dài là l. Dễ thấy, trong xâu s tồn tại xâu đối xứng độ dài l−2, l−4,… Tuy nhiên, xâu s không tồn tài xâu đối xứng độ dài l+2, l+4, … Như vậy, s thỏa mãn tính chất chia nhị phân. Chúng ta sẽ chia nhị phân để tìm độ dài lớn nhất có thể. Với mỗi độ dài l, chúng ta cần kiểm tra xem trong xâu có tồn tại một xâu con là xâu đối xứng độ dài l hay không. Để làm việc này, ta duyệt qua tất cả tất cả các xâu con độ dài l trong s.
Bài toán còn lại là: kiểm tra xem s[i..j] với (1≤i≤j≤m;(j−i+1)mod2=1) có phải là xâu đối xứng hay không.
Cách làm như sau. Gọi t là xâu s viết theo thứ tự ngược lại. Bằng thuật toán Hash, chúng ta có thể kiểm tra được một xâu con nào đó của t có bằng một xâu con nào đó của s hay không. Như vậy, chúng ta cần kiểm tra s[i..k] có bằng t[n−j+1..n−k+1] hay không với k là tâm đối xứng, nói cách khác k=(i+j)/2. Như vậy bài toán đã được giải. Độ phức tạp cho cách làm này là O(nlog(n)).